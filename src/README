Individual_Grid
----------------------
Mutation:

Crossover:

Calculate Fitness:

Generate Children:
XXXXXXXXXXXXXXXXXXXXXXXXXX
Individual_DE:
-----------------------
Mutation:

Crossover:

Calculate Fitness:

Generate Children:

XXXXXXXXXXXXXXXXXXXXXXXXXX
Both:

Generate Successors:
We implemented generate successors by creating two lists,
concatinating them into a single final_results. Once the 
final_results is established, we iterate through the list
and call generate_children 2 times, once for parent1 crossing
with parent2, and once parent2 crossing with parent1. The 
reason for the two calls for generate_children is so that 
we are able to effectively double our population by creating
mirror images of the crossover developed by two parents.

The two lists are created by tournament_selection, and 
by roulette_selection respectively.

tournament_selection takes in the population given and 
returns a list of the winners of the 2 person tournament.
Therefore, the list will be of size (population/2).

roulette_selection takes in the list generated by tournament_selection
and is able to generate another list of equal size using roulette_selection.
The selection works by calculating the maximum fitness, and is able to 
generate a random number (choice) which ranges from 0 to the maximum fitness.
Then, the members of the inputted list are checked to see if their fitness
is greater than or equal to the choice. The choice is generated wih each
iteration of the for loop, so that levels with a high fitness are more likely
to be selected with each iteration of the loop. This selection returns a list
labeled lucky_ones which is then concatinated with winners to create a final_results list. 